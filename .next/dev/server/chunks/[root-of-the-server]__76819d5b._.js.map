{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/angel/Downloads/MachineLearningAct/lib/ml-utils.ts"],"sourcesContent":["/**\n * Utilidades para cargar y usar modelos de Machine Learning\n * En una aplicación real, usarías librerías como TensorFlow.js o ONNX\n */\n\n// Simulación de loader de modelos\n// En producción, integrarías con librerías como:\n// - TensorFlow.js para modelos TF\n// - ONNX Runtime para modelos ONNX\n// - Python backend con FastAPI/Flask\n\nexport interface ModelMetrics {\n  accuracy?: number\n  silhouette_score?: number\n  model_type: string\n  description: string\n}\n\nexport interface PredictionResult {\n  prediction: number | string\n  probability?: number\n  confidence?: number\n  explanation: string\n}\n\nexport const loadModelMetrics = async () => {\n  try {\n    const response = await fetch(\"/models/metrics.json\")\n    return await response.json()\n  } catch (error) {\n    console.error(\"Error loading metrics:\", error)\n    return null\n  }\n}\n\nexport const makeLogisticPrediction = (\n  tenure: number,\n  monthlyCharges: number,\n  totalCharges: number,\n  contractMonthly: number,\n): PredictionResult => {\n  let probability = 0.5\n\n  // Lógica basada en patrones del dataset real\n  if (tenure < 12 && contractMonthly === 1) {\n    probability = 0.72\n  } else if (tenure > 48) {\n    probability = 0.15\n  } else if (tenure < 6) {\n    probability = 0.65\n  }\n\n  if (monthlyCharges > 100) {\n    probability += 0.1\n  } else if (monthlyCharges < 30) {\n    probability -= 0.15\n  }\n\n  // Normalizar\n  probability = Math.max(0, Math.min(1, probability))\n\n  return {\n    prediction: probability > 0.5 ? \"Churn\" : \"No Churn\",\n    probability,\n    confidence: Math.abs(probability - 0.5) * 2,\n    explanation:\n      probability > 0.5\n        ? `Con ${(probability * 100).toFixed(1)}% de probabilidad, el cliente podría irse. Antigüedad: ${tenure} meses, Cargos: $${monthlyCharges}/mes`\n        : `Baja probabilidad de churn (${(probability * 100).toFixed(1)}%). Cliente leal. Antigüedad: ${tenure} meses.`,\n  }\n}\n\nexport const makeKNNPrediction = (\n  tenure: number,\n  monthlyCharges: number,\n  totalCharges: number,\n): { churn: boolean; neighbors: string[]; distance: number } => {\n  // Simulación de búsqueda de vecinos cercanos\n  const distance = Math.sqrt(Math.pow((tenure - 30) / 50, 2) + Math.pow((monthlyCharges - 70) / 100, 2))\n\n  // Vecinos simulados basados en proximidad\n  const neighbors = []\n  if (tenure < 12) {\n    neighbors.push(\"Vecino 1: Churn = Sí\", \"Vecino 2: Churn = Sí\", \"Vecino 3: Churn = No\")\n  } else if (tenure > 48) {\n    neighbors.push(\"Vecino 1: Churn = No\", \"Vecino 2: Churn = No\", \"Vecino 3: Churn = No\")\n  } else {\n    neighbors.push(\"Vecino 1: Churn = No\", \"Vecino 2: Churn = Sí\", \"Vecino 3: Churn = No\")\n  }\n\n  // Agregar 2 más\n  neighbors.push(\"Vecino 4: Churn = No\", \"Vecino 5: Churn = No\")\n\n  const churnCount = neighbors.filter((n) => n.includes(\"Sí\")).length\n  const churn = churnCount > 2\n\n  return {\n    churn,\n    neighbors,\n    distance: Math.round(distance * 100) / 100,\n  }\n}\n\nexport const makeKMeansPrediction = (\n  balance: number,\n  purchases: number,\n  installments: number,\n): { cluster: number; distance: number; clusterSize: number; description: string } => {\n  const descriptions = [\n    \"Clientes Premium: Alto gasto, muy activos. Estrategia: Retención VIP y productos premium.\",\n    \"Clientes Estándar: Gasto moderado, perfil típico. Estrategia: Crecimiento y cross-selling.\",\n    \"Clientes Emergentes: Bajo gasto, potencial de crecimiento. Estrategia: Incentivos e onboarding.\",\n  ]\n\n  const clusterSizes = [2100, 3400, 3500]\n\n  let cluster = 2 // Default: emergentes\n\n  const totalSpend = balance + purchases + installments\n\n  if (purchases > 10000 && balance > 3000) {\n    cluster = 0 // Premium\n  } else if (purchases > 5000 && balance > 1500) {\n    cluster = 1 // Estándar\n  }\n\n  const distance = Math.random() * 5\n\n  return {\n    cluster,\n    distance: Math.round(distance * 100) / 100,\n    clusterSize: clusterSizes[cluster],\n    description: descriptions[cluster],\n  }\n}\n"],"names":[],"mappings":"AAAA;;;CAGC,GAED,kCAAkC;AAClC,iDAAiD;AACjD,kCAAkC;AAClC,mCAAmC;AACnC,qCAAqC;;;;;;;;;;;AAgB9B,MAAM,mBAAmB;IAC9B,IAAI;QACF,MAAM,WAAW,MAAM,MAAM;QAC7B,OAAO,MAAM,SAAS,IAAI;IAC5B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,0BAA0B;QACxC,OAAO;IACT;AACF;AAEO,MAAM,yBAAyB,CACpC,QACA,gBACA,cACA;IAEA,IAAI,cAAc;IAElB,6CAA6C;IAC7C,IAAI,SAAS,MAAM,oBAAoB,GAAG;QACxC,cAAc;IAChB,OAAO,IAAI,SAAS,IAAI;QACtB,cAAc;IAChB,OAAO,IAAI,SAAS,GAAG;QACrB,cAAc;IAChB;IAEA,IAAI,iBAAiB,KAAK;QACxB,eAAe;IACjB,OAAO,IAAI,iBAAiB,IAAI;QAC9B,eAAe;IACjB;IAEA,aAAa;IACb,cAAc,KAAK,GAAG,CAAC,GAAG,KAAK,GAAG,CAAC,GAAG;IAEtC,OAAO;QACL,YAAY,cAAc,MAAM,UAAU;QAC1C;QACA,YAAY,KAAK,GAAG,CAAC,cAAc,OAAO;QAC1C,aACE,cAAc,MACV,CAAC,IAAI,EAAE,CAAC,cAAc,GAAG,EAAE,OAAO,CAAC,GAAG,uDAAuD,EAAE,OAAO,iBAAiB,EAAE,eAAe,IAAI,CAAC,GAC7I,CAAC,4BAA4B,EAAE,CAAC,cAAc,GAAG,EAAE,OAAO,CAAC,GAAG,8BAA8B,EAAE,OAAO,OAAO,CAAC;IACrH;AACF;AAEO,MAAM,oBAAoB,CAC/B,QACA,gBACA;IAEA,6CAA6C;IAC7C,MAAM,WAAW,KAAK,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,SAAS,EAAE,IAAI,IAAI,KAAK,KAAK,GAAG,CAAC,CAAC,iBAAiB,EAAE,IAAI,KAAK;IAEnG,0CAA0C;IAC1C,MAAM,YAAY,EAAE;IACpB,IAAI,SAAS,IAAI;QACf,UAAU,IAAI,CAAC,wBAAwB,wBAAwB;IACjE,OAAO,IAAI,SAAS,IAAI;QACtB,UAAU,IAAI,CAAC,wBAAwB,wBAAwB;IACjE,OAAO;QACL,UAAU,IAAI,CAAC,wBAAwB,wBAAwB;IACjE;IAEA,gBAAgB;IAChB,UAAU,IAAI,CAAC,wBAAwB;IAEvC,MAAM,aAAa,UAAU,MAAM,CAAC,CAAC,IAAM,EAAE,QAAQ,CAAC,OAAO,MAAM;IACnE,MAAM,QAAQ,aAAa;IAE3B,OAAO;QACL;QACA;QACA,UAAU,KAAK,KAAK,CAAC,WAAW,OAAO;IACzC;AACF;AAEO,MAAM,uBAAuB,CAClC,SACA,WACA;IAEA,MAAM,eAAe;QACnB;QACA;QACA;KACD;IAED,MAAM,eAAe;QAAC;QAAM;QAAM;KAAK;IAEvC,IAAI,UAAU,EAAE,sBAAsB;;IAEtC,MAAM,aAAa,UAAU,YAAY;IAEzC,IAAI,YAAY,SAAS,UAAU,MAAM;QACvC,UAAU,GAAE,UAAU;IACxB,OAAO,IAAI,YAAY,QAAQ,UAAU,MAAM;QAC7C,UAAU,GAAE,WAAW;IACzB;IAEA,MAAM,WAAW,KAAK,MAAM,KAAK;IAEjC,OAAO;QACL;QACA,UAAU,KAAK,KAAK,CAAC,WAAW,OAAO;QACvC,aAAa,YAAY,CAAC,QAAQ;QAClC,aAAa,YAAY,CAAC,QAAQ;IACpC;AACF"}},
    {"offset": {"line": 150, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/angel/Downloads/MachineLearningAct/app/api/predict/knn/route.ts"],"sourcesContent":["import { type NextRequest, NextResponse } from \"next/server\"\nimport { makeKNNPrediction } from \"@/lib/ml-utils\"\n\nexport async function POST(request: NextRequest) {\n  try {\n    const data = await request.json()\n\n    const { tenure, monthlyCharges, totalCharges } = data\n\n    if (tenure === undefined || monthlyCharges === undefined || totalCharges === undefined) {\n      return NextResponse.json({ error: \"Faltan parámetros requeridos\" }, { status: 400 })\n    }\n\n    const result = makeKNNPrediction(tenure, monthlyCharges, totalCharges)\n\n    return NextResponse.json({\n      churn: result.churn,\n      neighbors: result.neighbors,\n      distance: result.distance,\n      prediction: result.churn ? \"Churn\" : \"No Churn\",\n    })\n  } catch (error) {\n    console.error(\"Error en predicción KNN:\", error)\n    return NextResponse.json({ error: \"Error al hacer la predicción\" }, { status: 500 })\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,OAAO,MAAM,QAAQ,IAAI;QAE/B,MAAM,EAAE,MAAM,EAAE,cAAc,EAAE,YAAY,EAAE,GAAG;QAEjD,IAAI,WAAW,aAAa,mBAAmB,aAAa,iBAAiB,WAAW;YACtF,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA+B,GAAG;gBAAE,QAAQ;YAAI;QACpF;QAEA,MAAM,SAAS,IAAA,yIAAiB,EAAC,QAAQ,gBAAgB;QAEzD,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,OAAO,OAAO,KAAK;YACnB,WAAW,OAAO,SAAS;YAC3B,UAAU,OAAO,QAAQ;YACzB,YAAY,OAAO,KAAK,GAAG,UAAU;QACvC;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAA+B,GAAG;YAAE,QAAQ;QAAI;IACpF;AACF"}}]
}